"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveStreamService = void 0;
const http_status_codes_1 = require("http-status-codes");
const config_1 = __importDefault(require("../../../config"));
const ApiError_1 = __importDefault(require("../../../errors/ApiError"));
const event_model_1 = require("../event/event.model");
const agora_access_token_1 = require("agora-access-token");
const livestream_model_1 = require("./livestream.model");
// Create Live Stream
const createLiveStreamToDB = async (user, payload) => {
    var _a, _b, _c;
    const { eventId, ...restPayload } = payload;
    // Check if event exists
    const event = await event_model_1.Event.findById(eventId);
    if (!event) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Event not found');
    }
    // Check authorization
    if (String(event.organizerId) !== String(user.authId)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'Only event organizer can create live stream');
    }
    // Validate scheduled start time
    if (restPayload.scheduledStartTime) {
        const scheduledStart = new Date(restPayload.scheduledStartTime);
        if (scheduledStart < new Date()) {
            throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Scheduled start time cannot be in the past');
        }
    }
    // Check if event already has active live stream
    const existingStream = await livestream_model_1.LiveStream.findOne({
        event: eventId,
        streamStatus: { $in: ['scheduled', 'starting', 'live'] },
    });
    if (existingStream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.CONFLICT, 'Event already has an active or scheduled live stream');
    }
    // Create live stream with proper defaults
    const liveStreamData = {
        event: eventId,
        streamer: user.authId,
        streamKey: '', // Will be auto-generated by pre-save middleware
        streamId: '', // Will be auto-generated by pre-save middleware
        streamStatus: 'scheduled',
        isLive: false,
        channelName: `${eventId}-${Date.now()}`, // Will be auto-generated by pre-save middleware
        maxViewers: restPayload.maxViewers || 10000,
        chatEnabled: (_a = restPayload.chatEnabled) !== null && _a !== void 0 ? _a : true,
        isRecorded: (_b = restPayload.isRecorded) !== null && _b !== void 0 ? _b : false,
        requiresApproval: (_c = restPayload.requiresApproval) !== null && _c !== void 0 ? _c : false,
        tags: restPayload.tags || [],
        allowedEmails: restPayload.allowedEmails || [],
        isActive: false,
        isUpcoming: true,
        ...restPayload,
    };
    // Create the live stream
    const liveStream = await livestream_model_1.LiveStream.create(liveStreamData);
    // Update event with live stream reference
    await event_model_1.Event.findByIdAndUpdate(eventId, {
        hasLiveStream: true,
        liveStreamId: liveStream._id,
    });
    return liveStream;
};
// Get Agora Token for Stream
// Get Agora Token for Stream
// Get Agora Token for Stream
const getAgoraTokenFromDB = async (user, streamId, role) => {
    var _a, _b;
    // Fetch the document with proper population
    const streamDoc = await livestream_model_1.LiveStream.findById(streamId)
        .populate('event', 'title description')
        .populate('streamer', 'name email profile')
        .lean();
    if (!streamDoc) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check authorization based on role
    if (role === 'broadcaster') {
        const canBroadcast = await livestream_model_1.LiveStream.canBroadcast(streamId, user.authId);
        if (!canBroadcast) {
            throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'You are not authorized to broadcast this stream');
        }
    }
    else {
        const canView = await livestream_model_1.LiveStream.canViewStream(streamId, user.authId);
        if (!canView) {
            throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'You are not authorized to view this stream');
        }
    }
    // Convert document to plain object WITH virtuals
    // Since we're using lean(), we need to manually calculate virtuals
    const streamObj = streamDoc;
    // Manually set the virtuals since lean() doesn't include them
    const isUpcoming = streamObj.streamStatus === 'scheduled' ||
        streamObj.streamStatus === 'starting';
    const isActive = streamObj.streamStatus === 'starting' || streamObj.streamStatus === 'live';
    // Check if stream is active
    if (!isActive && !isUpcoming) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Stream is not active or upcoming');
    }
    // Validate Agora configuration
    if (!((_a = config_1.default.agora) === null || _a === void 0 ? void 0 : _a.app_id) || !((_b = config_1.default.agora) === null || _b === void 0 ? void 0 : _b.app_certificate)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.INTERNAL_SERVER_ERROR, 'Agora configuration is missing');
    }
    // Generate Agora token
    const appID = config_1.default.agora.app_id;
    const appCertificate = config_1.default.agora.app_certificate;
    const channelName = streamObj.channelName;
    const uid = 0; // Let Agora assign UID
    const agoraRole = role === 'broadcaster' ? agora_access_token_1.RtcRole.PUBLISHER : agora_access_token_1.RtcRole.SUBSCRIBER;
    const expireTimeInSeconds = 3600; // 1 hour
    const currentTimestamp = Math.floor(Date.now() / 1000);
    const privilegeExpiredTs = currentTimestamp + expireTimeInSeconds;
    const token = agora_access_token_1.RtcTokenBuilder.buildTokenWithUid(appID, appCertificate, channelName, uid, agoraRole, privilegeExpiredTs);
    return {
        token,
        channelName,
        uid,
        role: agoraRole === agora_access_token_1.RtcRole.PUBLISHER ? 'publisher' : 'subscriber',
        expireTime: privilegeExpiredTs,
        streamingMode: streamObj.streamingMode,
    };
};
// Get All Live Streams
const getAllLiveStreamsFromDB = async (query) => {
    console.log({ query });
    const { page = 1, limit = 10, search, streamType, streamStatus, isLive, tags, sortBy = 'createdAt', sortOrder = 'desc', } = query;
    const skip = (page - 1) * limit;
    // Build filter
    const filter = {};
    if (search) {
        filter.$or = [
            { title: { $regex: search, $options: 'i' } },
            { description: { $regex: search, $options: 'i' } },
        ];
    }
    if (streamType) {
        filter.streamType = streamType;
    }
    if (streamStatus) {
        filter.streamStatus = streamStatus;
    }
    if (typeof isLive === 'boolean') {
        filter.isLive = isLive;
    }
    if (tags && tags.length > 0) {
        filter.tags = { $in: tags };
    }
    // Only show public streams for non-authenticated users
    // (You can modify this based on your auth middleware)
    filter.streamType = 'public';
    // Sort
    const sort = {};
    sort[sortBy] = sortOrder === 'desc' ? -1 : 1;
    // Execute query
    const [streams, total] = await Promise.all([
        livestream_model_1.LiveStream.find(filter)
            .populate({ path: 'event', select: 'title description' })
            .populate({ path: 'streamer', select: 'name email profile' })
            .sort(sort)
            .skip(skip)
            .limit(limit)
            .lean(),
        livestream_model_1.LiveStream.countDocuments(filter),
    ]);
    // Transform to response DTO
    const data = streams.map(stream => {
        var _a;
        return ({
            id: stream._id.toString(),
            event: {
                id: stream.event._id.toString(),
                title: stream.event.title,
                description: stream.event.description,
            },
            streamer: {
                id: stream.streamer._id.toString(),
                name: stream.streamer.name,
                email: stream.streamer.email,
                avatar: (_a = stream.streamer.profile) === null || _a === void 0 ? void 0 : _a.avatar,
            },
            title: stream.title,
            description: stream.description,
            channelName: stream.channelName,
            streamStatus: stream.streamStatus,
            isLive: stream.isLive,
            currentViewers: stream.currentViewers,
            maxViewers: stream.maxViewers,
            streamType: stream.streamType,
            chatEnabled: stream.chatEnabled,
            thumbnail: stream.thumbnail,
            playbackUrl: stream.playbackUrl,
            hlsUrl: stream.hlsUrl,
            scheduledStartTime: stream.scheduledStartTime,
            liveStartedAt: stream.liveStartedAt,
            createdAt: stream.createdAt,
            updatedAt: stream.updatedAt,
            isUpcoming: stream.isUpcoming,
            isActive: stream.isActive,
            requiresApproval: stream.requiresApproval,
            tags: stream.tags,
        });
    });
    return {
        success: true,
        statusCode: http_status_codes_1.StatusCodes.OK,
        message: 'Live streams retrieved successfully',
        meta: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit),
        },
        data,
    };
};
// Get My Live Streams (Streamer's streams)
const getMyLiveStreamsFromDB = async (user, query) => {
    const { page = 1, limit = 10, streamStatus, isLive } = query;
    const skip = (page - 1) * limit;
    const filter = { streamer: user.authId };
    if (streamStatus) {
        filter.streamStatus = streamStatus;
    }
    if (typeof isLive === 'boolean') {
        filter.isLive = isLive;
    }
    const [streams, total] = await Promise.all([
        livestream_model_1.LiveStream.find(filter)
            .populate('event', 'title description')
            .populate('streamer', 'name email profile')
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limit)
            .lean(),
        livestream_model_1.LiveStream.countDocuments(filter),
    ]);
    const data = streams.map(stream => {
        var _a;
        return ({
            id: stream._id.toString(),
            event: {
                id: stream.event._id.toString(),
                title: stream.event.title,
                description: stream.event.description,
            },
            streamer: {
                id: stream.streamer._id.toString(),
                name: stream.streamer.name,
                email: stream.streamer.email,
                avatar: (_a = stream.streamer.profile) === null || _a === void 0 ? void 0 : _a.avatar,
            },
            title: stream.title,
            description: stream.description,
            channelName: stream.channelName,
            streamStatus: stream.streamStatus,
            isLive: stream.isLive,
            currentViewers: stream.currentViewers,
            maxViewers: stream.maxViewers,
            streamType: stream.streamType,
            chatEnabled: stream.chatEnabled,
            thumbnail: stream.thumbnail,
            playbackUrl: stream.playbackUrl,
            hlsUrl: stream.hlsUrl,
            scheduledStartTime: stream.scheduledStartTime,
            liveStartedAt: stream.liveStartedAt,
            createdAt: stream.createdAt,
            updatedAt: stream.updatedAt,
            isUpcoming: stream.isUpcoming,
            isActive: stream.isActive,
            requiresApproval: stream.requiresApproval,
            tags: stream.tags,
        });
    });
    return {
        success: true,
        statusCode: http_status_codes_1.StatusCodes.OK,
        message: 'Your live streams retrieved successfully',
        meta: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit),
        },
        data,
    };
};
// Get Single Live Stream
const getSingleLiveStreamFromDB = async (streamId, user) => {
    var _a;
    const stream = await livestream_model_1.LiveStream.findById(streamId)
        .populate('event', 'title description')
        .populate('streamer', 'name email profile')
        .lean();
    if (!stream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check authorization for private streams
    const userId = user === null || user === void 0 ? void 0 : user.userId;
    const canView = await livestream_model_1.LiveStream.canViewStream(streamId, userId);
    if (!canView) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'You are not authorized to view this stream');
    }
    return {
        id: stream._id.toString(),
        event: {
            id: stream.event._id.toString(),
            title: stream.event.title,
            description: stream.event.description,
        },
        streamer: {
            id: stream.streamer._id.toString(),
            name: stream.streamer.name,
            email: stream.streamer.email,
            avatar: (_a = stream.streamer.profile) === null || _a === void 0 ? void 0 : _a.avatar,
        },
        title: stream.title,
        description: stream.description,
        channelName: stream.channelName,
        streamStatus: stream.streamStatus,
        isLive: stream.isLive,
        currentViewers: stream.currentViewers,
        maxViewers: stream.maxViewers,
        streamType: stream.streamType,
        chatEnabled: stream.chatEnabled,
        thumbnail: stream.thumbnail,
        playbackUrl: stream.playbackUrl,
        hlsUrl: stream.hlsUrl,
        scheduledStartTime: stream.scheduledStartTime,
        liveStartedAt: stream.liveStartedAt,
        createdAt: stream.createdAt,
        updatedAt: stream.updatedAt,
        isUpcoming: stream.isUpcoming,
        isActive: stream.isActive,
        requiresApproval: stream.requiresApproval,
        tags: stream.tags,
    };
};
// Update Live Stream
const updateLiveStreamToDB = async (user, streamId, payload) => {
    const stream = await livestream_model_1.LiveStream.findById(streamId);
    if (!stream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check if user is streamer
    if (String(stream.streamer) !== String(user.authId)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'Only streamer can update live stream');
    }
    // Don't allow updates if stream is live
    if (stream.isLive) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Cannot update stream while it is live');
    }
    const updatedStream = await livestream_model_1.LiveStream.findByIdAndUpdate(streamId, payload, {
        new: true,
        runValidators: true,
    });
    if (!updatedStream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.INTERNAL_SERVER_ERROR, 'Failed to update live stream');
    }
    return updatedStream;
};
// Delete Live Stream
const deleteLiveStreamToDB = async (user, streamId) => {
    const stream = await livestream_model_1.LiveStream.findById(streamId);
    if (!stream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check if user is streamer
    if (String(stream.streamer) !== String(user.authId)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'Only streamer can delete live stream');
    }
    // Don't allow deletion if stream is live
    if (stream.isLive) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Cannot delete stream while it is live');
    }
    // Remove reference from event
    await event_model_1.Event.findByIdAndUpdate(stream.event, {
        $unset: { liveStreamId: '' },
        hasLiveStream: false,
    });
    await livestream_model_1.LiveStream.findByIdAndDelete(streamId);
    return {
        id: streamId,
        title: stream.title,
    };
};
// Start Live Stream
const startLiveStreamToDB = async (user, streamId) => {
    const stream = await livestream_model_1.LiveStream.findById(streamId);
    if (!stream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check if user is streamer
    if (String(stream.streamer) !== String(user.authId)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'Only streamer can start live stream');
    }
    // Check if stream can be started
    if (stream.isLive) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Stream is already live');
    }
    if (stream.streamStatus === 'ended' || stream.streamStatus === 'cancelled') {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Cannot start a stream that has ended or been cancelled');
    }
    // Update stream status
    stream.streamStatus = 'live';
    stream.isLive = true;
    stream.liveStartedAt = new Date();
    await stream.save();
    return stream;
};
// End Live Stream
const endLiveStreamToDB = async (user, streamId) => {
    const stream = await livestream_model_1.LiveStream.findById(streamId);
    if (!stream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    // Check if user is streamer
    if (String(stream.streamer) !== String(user.authId)) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.FORBIDDEN, 'Only streamer can end live stream');
    }
    // Check if stream is live
    if (!stream.isLive) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.BAD_REQUEST, 'Stream is not live');
    }
    // Update stream status
    stream.streamStatus = 'ended';
    stream.isLive = false;
    stream.liveEndedAt = new Date();
    await stream.save();
    return stream;
};
// Update Viewer Count (for webhooks)
const updateViewerCountToDB = async (streamId, action) => {
    // Use atomic update to prevent race conditions
    const updateOperation = action === 'join'
        ? { $inc: { currentViewers: 1, totalViewers: 1 } }
        : { $inc: { currentViewers: -1 } };
    // We need to handle the "max(0)" logic for leaving. 
    // MongoDB $inc can result in negative numbers if we aren't careful, 
    // but for a simple viewer count, we usually trust the join/leave events match.
    // Ideally, we'd use a pipeline update or check for >= 0, 
    // but for now, simple $inc is much better than the race condition.
    const updatedStream = await livestream_model_1.LiveStream.findByIdAndUpdate(streamId, [
        {
            $set: {
                currentViewers: {
                    $max: [
                        0,
                        {
                            $add: [
                                '$currentViewers',
                                action === 'join' ? 1 : -1
                            ]
                        }
                    ]
                },
                totalViewers: {
                    $add: ['$totalViewers', action === 'join' ? 1 : 0]
                }
            }
        },
        // Update peak viewers if current > peak
        {
            $set: {
                peakViewers: { $max: ['$peakViewers', '$currentViewers'] }
            }
        }
    ], { new: true });
    if (!updatedStream) {
        throw new ApiError_1.default(http_status_codes_1.StatusCodes.NOT_FOUND, 'Live stream not found');
    }
    return {
        currentViewers: updatedStream.currentViewers,
        peakViewers: updatedStream.peakViewers,
    };
};
exports.LiveStreamService = {
    createLiveStreamToDB,
    getAgoraTokenFromDB,
    getAllLiveStreamsFromDB,
    getMyLiveStreamsFromDB,
    getSingleLiveStreamFromDB,
    updateLiveStreamToDB,
    deleteLiveStreamToDB,
    startLiveStreamToDB,
    endLiveStreamToDB,
    updateViewerCountToDB,
};
